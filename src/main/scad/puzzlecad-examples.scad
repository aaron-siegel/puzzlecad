include <puzzlecad.scad>

// This is a tutorial for puzzlecad, an OpenSCAD library for modeling mechanical puzzles.
// To obtain the latest version of puzzlecad: https://www.thingiverse.com/thing:3198014
// For an overview of interlocking puzzles: http://robspuzzlepage.com/interlocking.htm

// Puzzlecad is (c) 2019 Aaron Siegel and is licensed for use under the
// Creative Commons - Attribution license. A copy of this license is available here:
// https://creativecommons.org/licenses/by/3.0/

// To view the effect of any of the examples in this tutorial, just put this file in
// the same directory as puzzlecad.scad, load it in OpenSCAD, and remove the asterisk
// preceding that example. (But just one at a time - remove multiple asterisks and you'll
// get a jumbled mess!)

// ===== BASIC USAGE

// The basic puzzlecad command is the burr_piece module, which can be invoked in a variety
// of ways.

// Standard six-piece burr pieces can be generated by specifying their Kaenel number.
// (See http://robspuzzlepage.com/interlocking.htm for the definition of Kaenel number.)
// Here's the "right-handed offset":
*burr_piece(975);

// General burr pieces are given by strings composed of the characters "x" and ".", where "x"
// signifies a filled location and "." an empty one. The following example is a 5x4x1 board
// burr piece, from Yavuz Demirhan's Knotty 6. Note how there are 4 substrings of "x" and ".",
// each separated by a vertical bar "|".
*burr_piece("xxxx.|x..x.|x....|xxxxx");

// Multi-layer burr pieces are given by a vector of strings, one per layer. Here's a 6x3x2
// piece from From Demirhan's Nembus 2:
*burr_piece(["xxx.xx|x....x|xxxxxx", "......|......|x....x"]);

// Sometimes it's convenient to generate all the pieces of a puzzle at once. The convenience
// module burr_plate makes this easy to do. Bill Cutler's Burr #305:
*burr_plate([52, 615, 792, 960, 975, 992]);

// burr_plate arranges a whole vector of pieces on a single canvas. Demirhan's Nembus 2 in
// all its glory:
*burr_plate([
    ["xxxxxx|x....x|xxxxxx","......|......|x....x"],
    ["xxx.xx|x....x|xxxxxx","......|......|x....x"],
    ["xxx.xx|x....x|xxxxxx","......|......|x....x"],
    ["xxx.xx|x....x|xxxxxx","......|......|x....x"],
    ["xxx.xx|x....x|xxxxxx","......|......|x....x"],
    ["xxxxxx|x....x|xxx.xx","......|......|x....x"]
    ], $burr_inset = 0.05);

// Note the use of $burr_inset = 0.07. It's one of several parameters that tweak the burr
// piece geometry.
// $burr_scale specifies the size of a voxel (in millimeters). The default is 11.15.
// $burr_inset specifies how much the edges of each burr piece should be "trimmed back".
//     Smaller values give a tighter fit; larger values give a looser fit. The default is
//     0.07.
// $burr_bevel specifies how much to bevel the edges. The default is 0.5, which gives a very
//     slight, clean rounding. A value between 1 and 1.5 will better approximate typical
//     beveling used in wood puzzles. A value of 0 gives no beveling (sharp edges).


// ===== CONNECTORS

// Many puzzle pieces cannot be printed without supports, since there is no orientation for
// which they lie completely flat on the print bed. A good example of this is the following
// piece from Stewart Coffin's Interlock Four:
*burr_piece(["x..|xxx|...", "...|..x|..x"]);

// One solution to this is to use soluble supports, but not all printers have that capability.
// Puzzlecad provides an alternate option, using an idea originally due to Rich Gain. Pieces
// like the above can be printed in two separate components, which can then be locked together
// using "snap joints". Here's what that looks like in practice:
*burr_plate([["x..|xxx{connect=mz+}"], ["x{connect=fz+}|x"]]);

// After the two components are printed, they can be snapped into place in the obvious manner.
// That "{connect=mz+}" after the final "x" in the first component is an annotation: it tells
// puzzlecad to attach a male connector in the z+ direction. Likewise, "{connect=fz+}"
// specifies a female connector pointing in the z+ direction. A huge variety of puzzle
// shapes can be formed without supports using snap joints. Here's the full Interlock 4 puzzle:
*burr_plate([
    ["..x|xxx|x{connect=mz+,clabel=Ay-}.."], ["x|x", ".|x{connect=fz+,clabel=Ay-}"],
    ["x..|xxx|x.x", "...|...|x.."],
    ["x..|xxx{connect=mz+,clabel=Cy-}"], ["x{connect=fz+,clabel=Cy-}|x"],
    [".x|x{connect=mz+,clabel=Dy-}x"], ["x{connect=fz+,clabel=Dy-}x|.x"]
    ], $burr_scale = 14, $burr_inset = 0.07);

// Snap joints are supported in all six directions (x+, x-, y+, y-, z+, z-). Most shapes
// can be made with just mz+, fz+, and fz-; any connector types other than those three will
// need to be printed with supports. (However, since any support scars will be hidden
// within the joint, soluble supports are conveniently not necessary.)


